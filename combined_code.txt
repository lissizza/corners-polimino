##### ./vue.config.js #####

module.exports = {
  transpileDependencies: []
}


##### ./babel.config.js #####

module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}


##### ./src/App.vue #####

<!-- src/App.vue -->
<template>
  <div class="game-container">
    <div class="zones">
      <StartZone 
        :pieces="pieces" 
        @update:pieces="updateAvailablePieces"
      />
      <AnswerZone 
        :placedPieces="placedPieces" 
        @update:placedPieces="updatePlacedPieces"
        ref="answerZone"
      />
    </div>
    <div class="controls">
      <button @click="showAnswer">Получить Матрицу Ответа</button>
      <button @click="checkSolution">Проверить Решение</button>
    </div>
  </div>
</template>

<script>
import StartZone from './components/StartZone.vue';
import AnswerZone from './components/AnswerZone.vue';
import { pieces as initialPieces } from './data/pieces.js';

export default {
  name: 'App',
  components: {
    StartZone,
    AnswerZone
  },
  data() {
    return {
      pieces: initialPieces.map(piece => ({
        ...piece,
        position: { ...piece.initialPosition },  // Используем initialPosition как стартовую позицию
        rotation: piece.rotation || 0
      })),
      placedPieces: []
    };
  },
  methods: {
    updateAvailablePieces(updatedPieces) {
      this.pieces = updatedPieces;
    },
    updatePlacedPieces(updatedPlacedPieces) {
      this.placedPieces = updatedPlacedPieces;
    },
    showAnswer() {
      const answerMatrix = this.$refs.answerZone.getAnswer();
      console.table(answerMatrix);
      alert(JSON.stringify(answerMatrix, null, 2));
    },
    checkSolution() {
      const userMatrix = this.$refs.answerZone.getAnswer();
      const targetMatrix = this.getTargetMatrix();

      const isCorrect = userMatrix.every((row, rowIndex) => 
        row.every((cell, colIndex) => cell === targetMatrix[rowIndex][colIndex])
      );

      if (isCorrect) {
        alert('Поздравляем! Вы решили головоломку.');
      } else {
        alert('Расположение неверно. Попробуйте ещё раз.');
      }
    },
    getTargetMatrix() {
      // Целевая матрица 3x11 полностью заполнена без пустот
      return [
        Array(11).fill(1),
        Array(11).fill(1),
        Array(11).fill(1)
      ];
    }
  }
};
</script>

<style>
.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px;
}

.zones {
  display: flex;
  gap: 20px;
}

.controls {
  display: flex;
  gap: 10px;
}
</style>


##### ./src/main.js #####

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')


##### ./src/data/pieces.js #####

// src/data/pieces.js
export const pieces = [
    {
      id: 1,
      color: 'red',
      blocks: 3, // Основание 2 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 }, // Первый блок основания
        { x: 1, y: 0 }, // Второй блок основания
        { x: 0, y: 1 }  // Дополнительный блок слева сверху
      ],
      initialPosition: { x: 0, y: 0 },
      rotation: 0
    },
    {
      id: 2,
      color: 'blue',
      blocks: 4, // Основание 3 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 0, y: 1 } // Дополнительный блок слева сверху
      ],
      initialPosition: { x: 120, y: 0 }, // Смещено по x для предотвращения перекрытия
      rotation: 0
    },
    {
      id: 3,
      color: 'green',
      blocks: 5, // Основание 4 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 3, y: 0 },
        { x: 3, y: 1 } // Дополнительный блок справа сверху
      ],
      initialPosition: { x: 240, y: 0 }, // Смещено по x для предотвращения перекрытия
      rotation: 0
    },
    {
      id: 4,
      color: 'yellow',
      blocks: 6, // Основание 5 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 3, y: 0 },
        { x: 4, y: 0 },
        { x: 0, y: 1 } // Дополнительный блок слева сверху
      ],
      initialPosition: { x: 0, y: 120 }, // Смещено по y для предотвращения перекрытия
      rotation: 0
    },
    {
      id: 5,
      color: 'purple',
      blocks: 7, // Основание 6 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 3, y: 0 },
        { x: 4, y: 0 },
        { x: 5, y: 0 },
        { x: 5, y: 1 } // Дополнительный блок справа сверху
      ],
      initialPosition: { x: 120, y: 120 }, // Смещено по x и y для предотвращения перекрытия
      rotation: 0
    },
    {
      id: 6,
      color: 'orange',
      blocks: 8, // Основание 7 + 1 дополнительный блок
      shape: [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 3, y: 0 },
        { x: 4, y: 0 },
        { x: 5, y: 0 },
        { x: 6, y: 0 },
        { x: 6, y: 1 } // Дополнительный блок справа сверху
      ],
      initialPosition: { x: 240, y: 120 }, // Смещено по x и y для предотвращения перекрытия
      rotation: 0
    }
  ];
  

##### ./src/components/StartZone.vue #####

<template>
    <div class="start-zone">
      <draggable
        v-model="availablePieces"
        group="pieces"
        @end="onEnd"
        class="drag-container"
      >
        <template #item="{ element }">
          <div
            class="available-piece"
            :style="getPieceStyle(element)"
          >
            <PuzzlePiece :piece="element" @rotate="rotateAvailablePiece(element, $event)" />
          </div>
        </template>
      </draggable>
    </div>
  </template>
  
  <script>
  import draggable from 'vuedraggable';
  import PuzzlePiece from './PuzzlePiece.vue';
  
  export default {
    name: 'StartZone',
    components: {
      draggable,
      PuzzlePiece
    },
    props: {
      pieces: {
        type: Array,
        required: true
      }
    },
    data() {
      return {
        availablePieces: this.pieces
      };
    },
    methods: {
      onEnd() {
        this.$emit('update:pieces', this.availablePieces);
      },
      getPieceStyle(piece) {
        // Проверка, что у элемента есть координаты x и y
        const x = piece.position?.x || 0;
        const y = piece.position?.y || 0;

        return {
            position: 'absolute',
            top: `${y}px`,
            left: `${x}px`,
            cursor: 'grab',
            transform: `rotate(${piece.rotation || 0}deg)`
        };
      },
      rotateAvailablePiece(piece, angle) {
        piece.rotation = (piece.rotation + angle) % 360;
        if (!piece.position) {
            piece.position = { x: 0, y: 0 }; // Устанавливаем начальную позицию, если она отсутствует
        }
        this.$emit('update:pieces', [...this.availablePieces]);
      }
    }
  };
  </script>
  
  <style scoped>
  .start-zone {
    width: 800px;
    height: 150px;
    border: 2px solid #ccc;
    position: relative;
    background-color: #f9f9f9;
  }
  
  .drag-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }
  
  .available-piece {
    position: relative;
  }
  </style>
  

##### ./src/components/AnswerZone.vue #####

<template>
    <div class="answer-zone">
        <draggable
            v-model="localPlacedPieces"
            group="pieces"
            @end="onEnd"
            class="drag-container"
            :move="checkMove"
            >
            <template #item="{ element }">
                <div
                class="placed-piece"
                :style="getPieceStyle(element)"
                >
                <PuzzlePiece :piece="element" @rotate="rotatePiece(element, $event)" />
                </div>
            </template>
        </draggable>

      <svg :width="width" :height="height" class="answer-svg">
        <!-- Сетка -->
        <g>
          <g
            v-for="(row, rowIndex) in grid"
            :key="'row' + rowIndex"
          >
            <rect
              v-for="(cell, colIndex) in row"
              :key="'cell' + rowIndex + '-' + colIndex"
              :x="colIndex * cellSize"
              :y="rowIndex * cellSize"
              :width="cellSize"
              :height="cellSize"
              fill="#fff"
              stroke="#eee"
            />
          </g>
        </g>
      </svg>
    </div>
  </template>
  
  <script>
  import draggable from 'vuedraggable';
  import PuzzlePiece from './PuzzlePiece.vue';
  
  export default {
    name: 'AnswerZone',
    components: {
      draggable,
      PuzzlePiece
    },
    props: {
      placedPieces: {
        type: Array,
        required: true
      }
    },
    computed: {
      localPlacedPieces: {
        get() {
          return this.placedPieces;
        },
        set(value) {
          this.$emit('update:placedPieces', value);
        }
      },
      width() {
        return this.cols * this.cellSize;
      },
      height() {
        return this.rows * this.cellSize;
      },
      grid() {
        return Array.from({ length: this.rows }, () => Array(this.cols).fill(0));
      }
    },
    data() {
      return {
        rows: 3,
        cols: 11,
        cellSize: 30
      };
    },
    methods: {
        onEnd() {
          this.localPlacedPieces.forEach(piece => {
              if (!this.isPositionSuitable(piece)) {
              // Возвращаем элемент в стартовую зону
              piece.position = { x: 0, y: 0 };
              }
          });
          this.$emit('update:placedPieces', this.localPlacedPieces);
        },
      getPieceStyle(piece) {
        return {
          position: 'absolute',
          top: `${piece.position.y}px`,
          left: `${piece.position.x}px`,
          cursor: 'grab',
          transform: `rotate(${piece.rotation}deg)`
        };
      },
      rotatePiece(piece, angle) {
        piece.rotation = (piece.rotation + angle) % 360;
        if (!piece.position) {
            piece.position = { x: 0, y: 0 }; // Устанавливаем начальную позицию, если она отсутствует
        }
        this.$emit('update:placedPieces', [...this.placedPieces]);
      },
      getAnswer() {
        const matrix = Array.from({ length: this.rows }, () => Array(this.cols).fill(0));
        this.placedPieces.forEach(piece => {
          piece.shape.forEach(block => {
            const x = piece.position.x + block.x * this.cellSize;
            const y = piece.position.y + block.y * this.cellSize;
            const col = Math.floor(x / this.cellSize);
            const row = Math.floor(y / this.cellSize);
            if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
              matrix[row][col] = 1;
            }
          });
        });
        return matrix;
      }
    }
  };
  </script>
  
  <style scoped>
  .answer-zone {
    width: 330px; /* 11 * 30 */
    height: 90px; /* 3 * 30 */
    border: 2px solid #000;
    background-color: #f0f0f0;
    position: relative;
  }
  
  .drag-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  .placed-piece {
    position: absolute;
  }
  </style>
  

##### ./src/components/PuzzlePiece.vue #####

<!-- src/components/PuzzlePiece.vue -->
<template>
  <div
    class="piece-wrapper"
    draggable="true"
    @dragstart="onDragStart"
  >
    <svg
      :width="width"
      :height="height"
      :transform="'rotate(' + piece.rotation + ')'"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g>
        <rect
          v-for="(block, index) in piece.shape"
          :key="index"
          :x="block.x * cellSize"
          :y="block.y * cellSize"
          :width="cellSize"
          :height="cellSize"
          :fill="piece.color"
          stroke="#000"
        />
      </g>
    </svg>
    <div class="controls">
      <button @click.stop="rotateLeft">A</button>
      <button @click.stop="rotateRight">D</button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'PuzzlePiece',
  props: {
    piece: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      cellSize: 30 // Размер одного блока в пикселях
    };
  },
  computed: {
    width() {
      const maxX = Math.max(...this.piece.shape.map(block => block.x)) + 1;
      return maxX * this.cellSize;
    },
    height() {
      const maxY = Math.max(...this.piece.shape.map(block => block.y)) + 1;
      return maxY * this.cellSize;
    }
  },
  methods: {
    onDragStart(event) {
      event.dataTransfer.setData('application/json', JSON.stringify(this.piece));
      event.dataTransfer.effectAllowed = 'move';
    },
    rotateLeft() {
      this.$emit('rotate', -90);
    },
    rotateRight() {
      this.$emit('rotate', 90);
    }
  }
};
</script>

<style scoped>
.piece-wrapper {
  position: relative;
  display: inline-block;
  margin: 10px;
  cursor: grab;
}

.controls {
  position: absolute;
  top: -10px;
  right: -40px;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.controls button {
  width: 30px;
  height: 30px;
  cursor: pointer;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 3px;
}

.controls button:hover {
  background-color: #eee;
}
</style>


